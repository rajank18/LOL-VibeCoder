const { GoogleGenerativeAI } = require('@google/generative-ai');

class LLMScorer {
    constructor(apiKey) {
        if (!apiKey) {
            throw new Error('Google API key is required');
        }
        
        this.genAI = new GoogleGenerativeAI(apiKey);
        this.model = this.genAI.getGenerativeModel({ model: 'gemini-pro' });
    }

    /**
     * Score repository metrics using Google Generative AI
     * @param {Object} metrics - Repository metrics
     * @returns {Promise<Object>} Scoring results
     */
    async scoreRepository(metrics) {
        try {
            console.log('Sending metrics to LLM for scoring...');
            
            const prompt = this.createPrompt(metrics);
            const result = await this.model.generateContent(prompt);
            const response = await result.response;
            const text = response.text();
            
            console.log('LLM Response:', text);
            
            // Parse the JSON response
            const scoring = this.parseResponse(text);
            
            console.log('Parsed scoring:', scoring);
            return scoring;
            
        } catch (error) {
            console.error('LLM scoring failed:', error.message);
            console.log('Using fallback scoring...');
            return this.getFallbackScoring(metrics);
        }
    }

    /**
     * Create optimized prompt for LLM
     * @param {Object} metrics - Repository metrics
     * @returns {string} Formatted prompt
     */
    createPrompt(metrics) {
        return `Analyze this GitHub repository to detect if it's "vibe-coded" (AI-generated code). 

"Vibe-coded" means the code was generated by AI/LLMs rather than written by developers.

NODE.JS ANALYSIS:
- Total files: ${metrics.totalFiles}
- Total lines: ${metrics.totalLines}
- Comment lines: ${metrics.commentLines}
- Comments ratio: ${metrics.commentsRatio}
- Has README: ${metrics.hasReadme}
- Has tests: ${metrics.hasTests}
- File types: ${JSON.stringify(metrics.fileTypes)}
- Used branch: ${metrics.usedBranch || 'unknown'}

NODE.JS AI PATTERNS:
- Generic names: ${metrics.aiPatterns?.genericNames || 0} files
- Perfect formatting: ${metrics.aiPatterns?.perfectFormatting || 0} files
- Boilerplate code: ${metrics.aiPatterns?.boilerplateCode || 0} files
- Repetitive patterns: ${metrics.aiPatterns?.repetitivePatterns || 0} files

PYTHON ADVANCED ANALYSIS:
- Comments score: ${metrics.pythonAnalysis?.comments_score || 0}/10
- Naming score: ${metrics.pythonAnalysis?.naming_score || 0}/10
- Tests score: ${metrics.pythonAnalysis?.tests_score || 0}/10
- Examples score: ${metrics.pythonAnalysis?.examples_score || 0}/10
- Python highlights: ${JSON.stringify(metrics.pythonAnalysis?.highlights || [])}

CODE SAMPLES (first 3):
${metrics.codeSamples?.slice(0, 3).map(sample => 
  `File: ${sample.file} (${sample.extension}, ${sample.lines} lines)\n${sample.sample.substring(0, 500)}...`
).join('\n\n') || 'No code samples available'}

Detect AI-generated code patterns and rate 0-10. Return ONLY valid JSON in this exact format:
{
  "aiPatterns": 8,
  "codeStructure": 7,
  "documentation": 6,
  "complexity": 4,
  "highlights": ["Generic variable names", "Perfect formatting", "Boilerplate code"],
  "overall": 7.5,
  "isVibeCoded": true,
  "verdict": "ü§ñ LIKELY AI-GENERATED - High probability of vibe-coding detected!"
}

SCORING CRITERIA (0-10, higher = more AI-generated):
- aiPatterns: Generic names, perfect formatting, repetitive patterns (0-10)
- codeStructure: Boilerplate code, standard templates, lack of personal style (0-10)
- documentation: AI-generated comments, generic descriptions (0-10)
- complexity: Overly complex or suspiciously simple code (0-10)
- highlights: Array of AI-generated code indicators
- overall: Weighted average (0-10, higher = more AI-generated)
- isVibeCoded: true if overall >= 6, false otherwise
- verdict: Fun verdict message based on AI detection score

Respond with JSON only:`;
    }

    /**
     * Parse LLM response and extract JSON
     * @param {string} response - Raw LLM response
     * @returns {Object} Parsed scoring object
     */
    parseResponse(response) {
        try {
            // Try to extract JSON from the response
            const jsonMatch = response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                const jsonStr = jsonMatch[0];
                const parsed = JSON.parse(jsonStr);
                
                // Validate the response structure
                if (this.isValidScoring(parsed)) {
                    return parsed;
                }
            }
            
            throw new Error('Invalid JSON format in LLM response');
            
        } catch (error) {
            console.error('Failed to parse LLM response:', error.message);
            throw new Error('Could not parse LLM response as valid JSON');
        }
    }

    /**
     * Validate scoring object structure
     * @param {Object} scoring - Scoring object to validate
     * @returns {boolean} Whether the object is valid
     */
    isValidScoring(scoring) {
        return (
            typeof scoring === 'object' &&
            typeof scoring.aiPatterns === 'number' &&
            typeof scoring.codeStructure === 'number' &&
            typeof scoring.documentation === 'number' &&
            typeof scoring.complexity === 'number' &&
            Array.isArray(scoring.highlights) &&
            scoring.aiPatterns >= 0 && scoring.aiPatterns <= 10 &&
            scoring.codeStructure >= 0 && scoring.codeStructure <= 10 &&
            scoring.documentation >= 0 && scoring.documentation <= 10 &&
            scoring.complexity >= 0 && scoring.complexity <= 10 &&
            (scoring.overall === undefined || (typeof scoring.overall === 'number' && scoring.overall >= 0 && scoring.overall <= 10)) &&
            (scoring.isVibeCoded === undefined || typeof scoring.isVibeCoded === 'boolean') &&
            (scoring.verdict === undefined || typeof scoring.verdict === 'string')
        );
    }

    /**
     * Get fallback scoring when LLM fails
     * @param {Object} metrics - Repository metrics
     * @returns {Object} Fallback scoring
     */
    getFallbackScoring(metrics) {
        console.log('Using fallback scoring based on metrics...');
        
        // Calculate scores based on metrics
        
        const scoring = {
            aiPatterns: this.calculateAIPatternsScore(metrics),
            codeStructure: this.calculateCodeStructureScore(metrics),
            documentation: this.calculateDocumentationScore(metrics),
            complexity: this.calculateComplexityScore(metrics),
            highlights: this.generateAIHighlights(metrics)
        };
        
        // Add overall assessment
        scoring.overall = this.calculateOverallScore(scoring);
        scoring.isVibeCoded = scoring.overall >= 6; // Lower threshold for AI detection
        scoring.verdict = this.getVerdict(scoring.overall);
        
        return scoring;
    }

    /**
     * Calculate AI patterns score based on metrics
     * @param {Object} metrics - Repository metrics
     * @returns {number} AI patterns score (0-10, higher = more AI-like)
     */
    calculateAIPatternsScore(metrics) {
        let score = 0;
        
        // Use Node.js detected AI patterns
        if (metrics.aiPatterns) {
            score += metrics.aiPatterns.genericNames * 2;
            score += metrics.aiPatterns.perfectFormatting * 1.5;
            score += metrics.aiPatterns.boilerplateCode * 2;
            score += metrics.aiPatterns.repetitivePatterns * 1.5;
        }
        
        // Use Python analysis results
        if (metrics.pythonAnalysis && !metrics.pythonAnalysis.error) {
            // Convert Python scores to AI detection (higher Python scores = more AI-like)
            const pythonNaming = metrics.pythonAnalysis.naming_score || 0;
            const pythonComments = metrics.pythonAnalysis.comments_score || 0;
            
            // Low naming score from Python = more AI-like (generic names)
            if (pythonNaming < 4) score += 3;
            else if (pythonNaming < 6) score += 1;
            
            // High comments score from Python = more AI-like (excessive documentation)
            if (pythonComments > 8) score += 2;
            else if (pythonComments > 6) score += 1;
        }
        
        // High comment ratio might indicate AI-generated comments
        if (metrics.commentsRatio > 0.3) score += 3;
        else if (metrics.commentsRatio > 0.2) score += 2;
        else if (metrics.commentsRatio > 0.1) score += 1;
        
        // Very high file count might indicate AI generation
        if (metrics.totalFiles > 1000) score += 2;
        else if (metrics.totalFiles > 500) score += 1;
        
        // Perfect README presence (AI often generates READMEs)
        if (metrics.hasReadme) score += 1;
        
        // Test files present (AI often generates tests)
        if (metrics.hasTests) score += 1;
        
        // Multiple file types (AI generates diverse file structures)
        const fileTypeCount = Object.keys(metrics.fileTypes).length;
        if (fileTypeCount > 5) score += 2;
        else if (fileTypeCount > 3) score += 1;
        
        return Math.min(10, score);
    }

    /**
     * Calculate code structure score based on metrics
     * @param {Object} metrics - Repository metrics
     * @returns {number} Code structure score (0-10, higher = more AI-like)
     */
    calculateCodeStructureScore(metrics) {
        let score = 0;
        
        // Very organized structure might indicate AI generation
        if (metrics.totalFiles > 100 && metrics.totalFiles < 1000) score += 2;
        if (metrics.totalFiles > 50 && metrics.totalFiles < 500) score += 1;
        
        // High line count with good organization
        if (metrics.totalLines > 100000) score += 2;
        else if (metrics.totalLines > 50000) score += 1;
        
        // Balanced file-to-line ratio (AI tends to generate balanced code)
        const avgLinesPerFile = metrics.totalLines / metrics.totalFiles;
        if (avgLinesPerFile > 50 && avgLinesPerFile < 200) score += 2;
        else if (avgLinesPerFile > 20 && avgLinesPerFile < 100) score += 1;
        
        return Math.min(10, score);
    }

    /**
     * Calculate documentation score based on metrics
     * @param {Object} metrics - Repository metrics
     * @returns {number} Documentation score (0-10, higher = more AI-like)
     */
    calculateDocumentationScore(metrics) {
        let score = 0;
        
        // AI often generates comprehensive documentation
        if (metrics.hasReadme) score += 2;
        if (metrics.commentsRatio > 0.2) score += 3;
        else if (metrics.commentsRatio > 0.1) score += 2;
        else if (metrics.commentsRatio > 0.05) score += 1;
        
        // High documentation ratio might indicate AI generation
        if (metrics.commentsRatio > 0.3) score += 2;
        
        return Math.min(10, score);
    }

    /**
     * Calculate complexity score based on metrics
     * @param {Object} metrics - Repository metrics
     * @returns {number} Complexity score (0-10, higher = more AI-like)
     */
    calculateComplexityScore(metrics) {
        let score = 0;
        
        // AI often generates either very simple or overly complex code
        const avgLinesPerFile = metrics.totalLines / metrics.totalFiles;
        
        // Very simple code (AI boilerplate)
        if (avgLinesPerFile < 20) score += 3;
        else if (avgLinesPerFile < 50) score += 1;
        
        // Overly complex single files (AI might generate complex functions)
        if (avgLinesPerFile > 500) score += 2;
        else if (avgLinesPerFile > 200) score += 1;
        
        // High total complexity
        if (metrics.totalLines > 200000) score += 2;
        else if (metrics.totalLines > 100000) score += 1;
        
        return Math.min(10, score);
    }

    /**
     * Generate AI detection highlights based on metrics
     * @param {Object} metrics - Repository metrics
     * @returns {Array<string>} Array of AI detection highlights
     */
    generateAIHighlights(metrics) {
        const highlights = [];
        
        // Use combined highlights if available
        if (metrics.combinedHighlights && metrics.combinedHighlights.length > 0) {
            highlights.push(...metrics.combinedHighlights);
        } else {
            // Fallback to individual highlights
            if (metrics.pythonAnalysis && metrics.pythonAnalysis.highlights) {
                highlights.push(...metrics.pythonAnalysis.highlights);
            }
        }
        
        // Add Node.js specific highlights
        if (metrics.commentsRatio > 0.3) {
            highlights.push('Excessive documentation (AI-generated comments)');
        } else if (metrics.commentsRatio > 0.2) {
            highlights.push('High comment ratio');
        }
        
        // Perfect project structure
        if (metrics.hasReadme && metrics.hasTests) {
            highlights.push('Perfect project structure (AI-generated)');
        } else if (metrics.hasReadme) {
            highlights.push('README present');
        }
        
        if (metrics.hasTests) {
            highlights.push('Test files present');
        }
        
        // Large codebase patterns
        if (metrics.totalFiles > 1000) {
            highlights.push('Massive codebase (AI generation pattern)');
        } else if (metrics.totalFiles > 100) {
            highlights.push('Large codebase');
        }
        
        // File type diversity
        const fileTypeCount = Object.keys(metrics.fileTypes).length;
        if (fileTypeCount > 5) {
            highlights.push('Multi-language project (AI diversity)');
        }
        
        // Complexity patterns
        const avgLinesPerFile = metrics.totalLines / metrics.totalFiles;
        if (avgLinesPerFile < 20) {
            highlights.push('Simple boilerplate code');
        } else if (avgLinesPerFile > 200) {
            highlights.push('Overly complex files');
        }
        
        // Python analysis highlights
        if (metrics.pythonAnalysis && !metrics.pythonAnalysis.error) {
            const python = metrics.pythonAnalysis;
            if (python.naming_score < 4) {
                highlights.push('Generic naming patterns detected');
            }
            if (python.comments_score > 8) {
                highlights.push('Excessive AI-generated comments');
            }
            if (python.tests_score === 0) {
                highlights.push('No test files found');
            }
        }
        
        // Remove duplicates
        const uniqueHighlights = [...new Set(highlights)];
        
        if (uniqueHighlights.length === 0) {
            uniqueHighlights.push('Basic project structure');
        }
        
        return uniqueHighlights;
    }

    /**
     * Calculate overall score from individual scores
     * @param {Object} scoring - Individual scores
     * @returns {number} Overall score (0-10)
     */
    calculateOverallScore(scoring) {
        // Weighted average for AI detection
        const weights = {
            aiPatterns: 0.3,      // Most important for AI detection
            codeStructure: 0.25,   // Code organization patterns
            documentation: 0.25,   // Documentation patterns
            complexity: 0.2        // Complexity patterns
        };
        
        const overall = (
            scoring.aiPatterns * weights.aiPatterns +
            scoring.codeStructure * weights.codeStructure +
            scoring.documentation * weights.documentation +
            scoring.complexity * weights.complexity
        );
        
        return Math.round(overall * 10) / 10; // Round to 1 decimal
    }

    /**
     * Get verdict based on overall score
     * @param {number} overallScore - Overall score (0-10)
     * @returns {string} Verdict message
     */
    getVerdict(overallScore) {
        if (overallScore >= 8.5) {
            return "ü§ñ DEFINITELY AI-GENERATED - This is 100% vibe-coded!";
        } else if (overallScore >= 7) {
            return "ü§ñ LIKELY AI-GENERATED - High probability of vibe-coding!";
        } else if (overallScore >= 6) {
            return "ü§î POSSIBLY AI-GENERATED - Some AI patterns detected";
        } else if (overallScore >= 4) {
            return "üë®‚Äçüíª MIXED - Some AI assistance, mostly human-written";
        } else if (overallScore >= 2) {
            return "üë®‚Äçüíª LIKELY HUMAN-WRITTEN - Minimal AI patterns";
        } else {
            return "üë®‚Äçüíª DEFINITELY HUMAN-WRITTEN - Pure human coding!";
        }
    }
}

module.exports = LLMScorer;